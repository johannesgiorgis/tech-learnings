# Chapter 4: Generic Types

- Used in the representation of nullable values, error handling, collections, and more

## What are Generic Types?

Allow us to partially define a `struct` or `enum`, enabling a compilter to create a fully defined version at compile-time based off our code usage.

Rust generally can infer the final type by looking at our instantiation, but if it needs help you can always be explicit using the `::<T>` operator aka `turbofish`.

## Representing Nothing

Rust does not have `null`, but it is not ignorant of the importance of representing nothing!

This pattern of providing a `None` alternative representation for one or many alternate values is so common in Rust because of its lack of a `null` value. Generic types help solve this challenge.

## Option

`Option` is a built in generic enum that allows us to represent nullable values with using `null`.

```rust
enum Option<T> {
    None,
    Some(T),
}
```

This enum is so common, instances of the enum can be created anywhere with the enum variants `Some` and `None`.

## Result

`Result` is a built in generic enum that allows us to return a value that has the possibility of failing. It is the idiomatic way in which the language does error handling.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

This enum is so common, instances of the enum can be created anywhere with the enum variants `Ok` and `Err`.

`main` has the capability of returning a `Result`!

## Graceful Error Handling

`Result` is so common that Rust has a powerful operator `?` for working with them. These two statements are equivalent:

```rust
do_something_that_might_fail()?

match do_something_that_might_fail() {
    Ok(v) => v,
    Err(e) => return Err(e),
}
```

## Ugly Option/Result Handling

It can be tedious working with `Option`/`Result` when you are trying to write some quick code. Both have a function called `unwrap` that can be useful for getting a value in a quick and dirty manner. `unwrap` will:

1. Get the value inside Option/Result
1. If enum is of type None, Err, `panic!`

These two pieces of code are equivalent:

```rust
my_option.unwrap()

match my_option {
    Some(v) => v,
    None => panic!("some error message generated by Rust!"),
}
```

Similarly:

```rust
my_result.unwrap()

match my_result {
    Ok(v) => v,
    Err(e) => panic!("some error message generated by Rust!"),
}
```

## Vectors

Some of the most useful generic types are collectiont types. A vector is a variably sized list of items represented by the struct `Vec`.

The macro `vec!` lets us easily create a vector rather than manually constructing one.

`Vec` has the method `iter()` which creates an iterator from a vector, allowing us to easily put a vector into a `for` loop.

Memory Details:

- `Vec` is a struct, but internally it contains a reference to a fixed list of its items on the heap.
- A vector starts with a default capacity; when more items are added than it has capacity for, it reallocates its data on the heap to have a new fixed list with large capacity.
